#! /usr/bin/env python

###########################################################
# addFloadCoords2TiePoints.py
# A script to add coordinates of floating image and calculate
# offests to tie points file generated by RSGISLib
#
# Dan Clewley (daniel.clewley@gmail.com) - 15/02/2013
###########################################################

import os, sys
import osgeo.gdal as gdal
import numpy as np
import csv

if len(sys.argv) != 4:
    print('''Not enough parameters provided.
Usage:
    python addFloatCoords2TiePoints.py inImageFile inTiePointFile.csv outTiePointFile.csv
''')
    exit()

inImageFile = sys.argv[1]
inGCPFile = sys.argv[2]
outGCPFile = sys.argv[3]

# Get information from image
dataset = gdal.Open(inImageFile, gdal.GA_ReadOnly )
projection = dataset.GetProjection()
geotransform = dataset.GetGeoTransform()
xSize = dataset.RasterXSize
ySize = dataset.RasterYSize

# Get geoinfo from image
minX = geotransform[0]
maxY = geotransform[3]
pixSizeX = geotransform[1]
pixSizeY = geotransform[5]
maxX = minX + (xSize * pixSizeX)
minY = maxY + (ySize * pixSizeY)

try:
    inGCPs = np.genfromtxt(inGCPFile, delimiter=',', comments='#')
except IOError:
    print('ERROR: In text file contains no points!')
    exit()

try:
    # Get coordinates from float image based on pixel in tie point file
    # Coordinates start at zero
    floatXCoords = minX + ((inGCPs[:,2]-1) * pixSizeX) 
    floatYCoords = maxY + ((inGCPs[:,3]-1) * pixSizeY) 
    
    # Calculate differences between base image coordinates (stored in tie point file)
    # and coordinates in floating image.
    diffX = floatXCoords - inGCPs[:,0]
    diffY = floatYCoords - inGCPs[:,1]
    
    # Express difference in pixels
    diffXPix = diffX / pixSizeX
    diffYPix = diffY / pixSizeY 
    
    # Calculate aplitude and phase (for plottong)
    phaseDiffPix = np.arctan(abs(diffYPix) / abs(diffXPix)) * 180. / np.pi
    
    phaseDiffPix = np.where(np.logical_and(diffXPix < 0, diffYPix < 0) ,phaseDiffPix + 180.,phaseDiffPix)
    phaseDiffPix = np.where(np.logical_and(diffXPix < 0, diffYPix > 0) ,phaseDiffPix + 90, phaseDiffPix)
    phaseDiffPix = np.where(np.logical_and(diffXPix > 0, diffYPix < 0) ,phaseDiffPix + 270, phaseDiffPix)
        
    powerDiffPix = np.sqrt(diffXPix**2 + diffYPix**2)
    
    sqDiffX = (inGCPs[:,0] - floatXCoords)**2
    sqDiffY = (inGCPs[:,1] - floatYCoords)**2
    
    rmseX = np.sqrt(np.average(sqDiffX))
    rmseY = np.sqrt(np.average(sqDiffY))
    
    print('RMSE (map units): x ' + str(rmseX) + ', y ' +str(rmseY))
    print('RMSE (pixels): x ' + str(rmseX / pixSizeX) + ', y ' + str(rmseY / np.abs(pixSizeY)))
    
    # Write data out to CSV file
    outGCPs = csv.writer(open(outGCPFile,'w'))
    
    outGCPs.writerow(['baseE','baseN','floatE','floatN','diffE','diffN','diffXPix','diffYPix','powerPixDiff','phasePixDiff'])
    
    for i in range(inGCPs.shape[0]):
        outGCPs.writerow([inGCPs[i,0],inGCPs[i,1],floatXCoords[i], floatYCoords[i], diffX[i], diffY[i], diffXPix[i],diffYPix[i], powerDiffPix[i], phaseDiffPix[i]])

except IndexError:
    print('ERROR: Not enough columns in infile')


